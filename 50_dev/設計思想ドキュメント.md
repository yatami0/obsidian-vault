
このドキュメントは、リポジトリの**設計意図**と**アーキテクチャ思想**を解説します。

「なぜこのような構造になっているのか」を理解することで、テンプレートとして活用する際に適切な判断ができるようになります。

  

---

  

## 目次

  

1. [設計の全体像](#設計の全体像)

2. [抽象レイヤー（設計原則）](#抽象レイヤー設計原則)

3. [具象レイヤー（実装例）](#具象レイヤー実装例)

4. [ディレクトリ設計の意図](#ディレクトリ設計の意図)

5. [テンプレートとして使う際のポイント](#テンプレートとして使う際のポイント)

  

---

  

## 設計の全体像

  

### アーキテクチャの二層構造

  

このリポジトリの設計は、**抽象（Why/What）** と **具象（How）** の2つのレイヤーで構成されています。

  

```

┌─────────────────────────────────────────────────────────┐

│                    抽象レイヤー                          │

│            （設計原則・パターン・思想）                    │

│                                                         │

│  • Server-First の原則                                  │

│  • 関心の分離（Separation of Concerns）                  │

│  • 型駆動設計（Type-Driven Development）                 │

│  • Container/Presentational パターン                    │

│  • 単一責任の原則                                        │

└───────────────────────────┬─────────────────────────────┘

                            │

                            │ 原則を適用

                            ▼

┌─────────────────────────────────────────────────────────┐

│                    具象レイヤー                          │

│          （このリポジトリの具体的な実装）                  │

│                                                         │

│  • Next.js App Router + RSC                             │

│  • Drizzle ORM + SQLite                                 │

│  • Jotai による状態管理                                  │

│  • 社員管理システムのサンプル実装                         │

└─────────────────────────────────────────────────────────┘

```

  

### なぜ二層に分けて考えるのか？

  

| 観点 | 抽象レイヤー | 具象レイヤー |

|------|-------------|-------------|

| **変化の頻度** | 低い（原則は普遍的） | 高い（技術は変化する） |

| **適用範囲** | どのプロジェクトでも | このプロジェクト固有 |

| **学習価値** | 長期的に使える知識 | 具体的な実装スキル |

| **置き換え可能性** | 変更不可 | 別の技術に置換可能 |

  

---

  

## 抽象レイヤー（設計原則）

  

### 原則1: Server-First Architecture

  

**思想**: データ取得とレンダリングはサーバー側で行い、クライアントには最小限の責務のみを持たせる

  

```

【なぜ Server-First なのか？】

  

1. パフォーマンス

   - 初回表示が高速（サーバーでHTMLを生成）

   - JavaScriptバンドルサイズの削減

   - データベースへの直接アクセス（API層不要）

  

2. セキュリティ

   - 機密ロジックがクライアントに露出しない

   - データベース接続情報がブラウザに渡らない

  

3. シンプルさ

   - データ取得 → 表示の流れが直線的

   - 状態管理の複雑さが減少

```

  

**抽象的なルール**:

```

┌─────────────────────────────────────────────────┐

│ Server Component                                │

│ 責務: データ取得、認証、リダイレクト              │

│      メタデータ設定、初期レンダリング             │

└────────────────────┬────────────────────────────┘

                     │ Props（シリアライズ可能なデータ）

                     ▼

┌─────────────────────────────────────────────────┐

│ Client Component ("use client")                 │

│ 責務: インタラクション、アニメーション            │

│      ローカル状態管理、ブラウザAPI使用           │

└─────────────────────────────────────────────────┘

```

  

---

  

### 原則2: 関心の分離（Separation of Concerns）

  

**思想**: 各レイヤーは自分の責務のみを持ち、他のレイヤーの詳細を知らない

  

```

【3層アーキテクチャ】

  

┌─────────────────────────────────────────────────┐

│ Presentation Layer（表示層）                     │

│                                                 │

│ 責務:                                           │

│ • ルーティング                                   │

│ • レイアウト                                     │

│ • ページ構成                                     │

│                                                 │

│ 知らないこと:                                    │

│ • データベースの存在                              │

│ • SQLの書き方                                    │

│ • 状態管理の仕組み                               │

└────────────────────┬────────────────────────────┘

                     │

┌────────────────────▼────────────────────────────┐

│ Application Layer（アプリケーション層）           │

│                                                 │

│ 責務:                                           │

│ • UI状態管理                                    │

│ • ビジネスロジック                               │

│ • ユーザーインタラクション                        │

│                                                 │

│ 知らないこと:                                    │

│ • データベーススキーマ                            │

│ • ルーティングの仕組み                            │

└────────────────────┬────────────────────────────┘

                     │

┌────────────────────▼────────────────────────────┐

│ Data Layer（データ層）                           │

│                                                 │

│ 責務:                                           │

│ • データベースアクセス                           │

│ • データの正規化                                 │

│ • 型の変換                                       │

│                                                 │

│ 知らないこと:                                    │

│ • UIの存在                                      │

│ • ユーザー操作                                   │

└─────────────────────────────────────────────────┘

```

  

**なぜ分離するのか？**

1. **変更の影響範囲を限定**: DBを変えてもUIに影響しない

2. **テスト容易性**: 各層を独立してテスト可能

3. **チーム分業**: フロントエンド/バックエンドで並行開発

  

---

  

### 原則3: 型駆動設計（Type-Driven Development）

  

**思想**: 型を先に定義し、実装はその型に従う

  

```

【型の階層構造】

  

レベル1: ドメイン型（ビジネスの言葉）

├── EmployeeProfile    → 「社員プロフィール」を表す

├── CompatibilityResult → 「相性診断結果」を表す

└── TeamAnalysis       → 「チーム分析」を表す

  

レベル2: 構成要素型（ドメイン型を構成する部品）

├── EmployeeBasicInfo  → 社員の基本情報

├── StrengthRanking    → 資質ランキング

└── FFSScore           → FFS診断スコア

  

レベル3: プリミティブ型（最小単位）

├── StrengthName       → "達成欲" | "活発性" | ...（Union型）

├── FFSFactor          → "凝縮性" | "受容性" | ...

└── UserRole           → "employee" | "admin"

```

  

**なぜ型を先に定義するのか？**

1. **仕様の明確化**: 型がそのまま仕様書になる

2. **コンパイル時エラー**: 実行前に問題を検出

3. **自己文書化**: コードを読めば構造がわかる

  

---

  

### 原則4: Container/Presentational パターン

  

**思想**: ロジックを持つコンポーネントと、表示のみのコンポーネントを分離する

  

```

【パターンの構造】

  

Container Component（コンテナ）

├── 責務

│   ├── 状態管理（useState, useAtom）

│   ├── データ取得・変換

│   ├── イベントハンドリング

│   └── 子コンポーネントへのデータ配布

│

└── 特徴

    ├── "use client" が必要

    ├── Jotai Atoms を使用

    ├── ビジネスロジックを含む

    └── 他のContainerを呼ばない

  

Presentational Component（プレゼンテーショナル）

├── 責務

│   ├── Props を受け取る

│   ├── UIを描画する

│   └── イベントを親に伝える（コールバック）

│

└── 特徴

    ├── Propsのみで動作

    ├── 内部状態は最小限（UIのみ）

    ├── テストが容易

    └── Storybook で独立確認可能

```

  

**なぜ分離するのか？**

1. **再利用性**: Presentationalは他のContainerでも使える

2. **テスト容易性**: Propsだけでテスト可能

3. **可読性**: 責務が明確でコードが読みやすい

  

---

  

### 原則5: 単一責任の原則（Single Responsibility Principle）

  

**思想**: 1つのモジュール（ファイル、関数、コンポーネント）は1つの責務のみを持つ

  

```

【適用例】

  

❌ 悪い例: 1つのコンポーネントで全部やる

EmployeeProfilePage

├── データ取得（fetch）

├── 状態管理（useState x 10）

├── 編集ロジック

├── 保存ロジック

├── AI生成ロジック

├── 基本情報表示

├── 資質リスト表示

├── チャート表示

└── → 500行超えのモンスターコンポーネント

  

✅ 良い例: 責務で分割

EmployeeProfilePage (Container)

├── 状態管理（編集モード）

└── 子コンポーネントの組み立て

  

ProfileHeader (Presentational)

└── ヘッダー部分の表示

  

BasicInfoCard (Presentational)

└── 基本情報カードの表示

  

StrengthsList (Presentational)

└── 資質リストの表示

  

FFSChart (Presentational)

└── レーダーチャートの表示

  

→ 各コンポーネントは50行以下で明確

```

  

**分割の判断基準**:

- 50行を超えたら分割を検討

- 「〇〇と△△を担当」と言えたら分割すべき

- テストで複数の観点があれば分割すべき

  

---

  

## 具象レイヤー（実装例）

  

ここからは、上記の抽象原則がこのリポジトリでどのように実装されているかを説明します。

  

### 具象1: Server-First の実装

  

**原則**: Server Component でデータ取得、Client Component で操作

  

```typescript

// ========================================

// 【Server Component】app/employees/page.tsx

// ========================================

// データベースに直接アクセスしてデータを取得

// クライアントにはデータのみを渡す

  

import { getAllEmployees, getDepartments } from "@/db/queries/employees";

import { EmployeeListPage } from "@/app/_components/employees/EmployeeListPage";

  

export default async function Page() {

  // ✅ サーバー側でDB問い合わせ（クライアントはDBを知らない）

  const employees = await getAllEmployees();

  const departments = await getDepartments();

  

  // ✅ Propsでデータを渡す（シリアライズされる）

  return (

    <EmployeeListPage

      employees={employees}

      departments={departments}

    />

  );

}

```

  

```typescript

// ========================================

// 【Client Component】app/_components/employees/EmployeeListPage.tsx

// ========================================

// Propsでデータを受け取り、UIインタラクションを担当

  

"use client";

  

import { useState, useMemo } from "react";

import { EmployeeProfile } from "@/app/_types/employee";

  

interface Props {

  employees: EmployeeProfile[];  // Serverから受け取る

  departments: string[];

}

  

export function EmployeeListPage({ employees, departments }: Props) {

  // ✅ クライアント側のUI状態のみ管理

  const [keyword, setKeyword] = useState("");

  const [selectedDepartment, setSelectedDepartment] = useState("");

  

  // ✅ 派生データはメモ化

  const filteredEmployees = useMemo(() => {

    return employees.filter(emp =>

      emp.basicInfo.name.includes(keyword) &&

      (!selectedDepartment || emp.basicInfo.department === selectedDepartment)

    );

  }, [employees, keyword, selectedDepartment]);

  

  return (

    <div>

      <input

        value={keyword}

        onChange={(e) => setKeyword(e.target.value)}

      />

      {/* ... */}

    </div>

  );

}

```

  

---

  

### 具象2: 3層アーキテクチャの実装

  

**原則**: Presentation → Application → Data の依存方向

  

```

【このリポジトリでの実装】

  

Presentation Layer

├── app/employees/page.tsx           # ページ（ルーティング）

├── app/employees/[id]/page.tsx      # 動的ページ

└── app/layout.tsx                   # レイアウト

  

Application Layer

├── app/_components/employees/       # 社員管理UI

├── app/_components/profile/         # プロフィールUI

├── app/_stores/employeeListAtoms.ts # 状態管理

└── app/_hooks/useProfileEdit.ts     # カスタムフック

  

Data Layer

├── db/schema.ts                     # テーブル定義

├── db/queries/employees.ts          # クエリ関数

└── db/index.ts                      # DB接続

```

  

**依存の流れ**:

```

app/employees/page.tsx

    │

    ├──→ db/queries/employees.ts (データ取得)

    │         │

    │         └──→ db/schema.ts (テーブル定義)

    │

    └──→ app/_components/employees/EmployeeListPage.tsx (UI)

              │

              └──→ app/_types/employee.ts (型定義)

```

  

**重要**: 矢印は常に上から下へ流れる。下から上への依存は禁止。

  

---

  

### 具象3: 型定義の実装

  

**原則**: ビジネスドメインを型で表現

  

```typescript

// ========================================

// app/_types/employee.ts

// ========================================

  

// ----------------------------------------

// レベル3: プリミティブ型（最小単位）

// ----------------------------------------

  

// 34資質の名前（StrengthsFinder）

export type StrengthName =

  | "達成欲" | "活発性" | "適応性" | "分析思考" | "アレンジ"

  | "信念" | "指令性" | "コミュニケーション" | "競争性" | "運命思考"

  | "原点思考" | "慎重さ" | "成長促進" | "規律性" | "共感性"

  | "公平性" | "未来志向" | "調和性" | "着想" | "包含"

  | "個別化" | "収集心" | "内省" | "学習欲" | "最上志向"

  | "ポジティブ" | "親密性" | "責任感" | "回復志向" | "自己確信"

  | "自我" | "戦略性" | "社交性" | "目標志向";

  

// FFS 5因子

export type FFSFactor =

  | "凝縮性" | "受容性" | "弁別性" | "拡散性" | "保全性";

  

// ユーザー権限

export type UserRole = "employee" | "admin";

  

// ----------------------------------------

// レベル2: 構成要素型

// ----------------------------------------

  

export interface EmployeeBasicInfo {

  id: string;

  name: string;

  department: string;

  position: string;

  email: string;

  avatarUrl?: string;

}

  

export interface StrengthRanking {

  rank: number;        // 1-34

  name: StrengthName;  // ← プリミティブ型を使用

  comment?: string;

}

  

export interface FFSScore {

  factor: FFSFactor;   // ← プリミティブ型を使用

  score: number;       // 0-100

}

  

// ----------------------------------------

// レベル1: ドメイン型（ビジネスの単位）

// ----------------------------------------

  

export interface EmployeeProfile {

  basicInfo: EmployeeBasicInfo;     // ← 構成要素型を使用

  strengths: StrengthRanking[];     // ← 構成要素型を使用

  ffsScores: FFSScore[];            // ← 構成要素型を使用

  selfPR?: string;

}

  

export interface AIDescription {

  generalTraits: string;      // 一般的な特性

  effectiveApproach: string;  // 効果的なアプローチ

  managementStyle: string;    // マネジメントスタイル

  generatedAt: string;

  isLoading?: boolean;

  error?: string;

}

```

  

**なぜこの階層構造なのか？**

- **プリミティブ型**: 値の制約を表現（不正な値をコンパイル時に防ぐ）

- **構成要素型**: 再利用可能な小さな単位

- **ドメイン型**: ビジネスで意味を持つ単位

  

---

  

### 具象4: Container/Presentational の実装

  

**原則**: ロジックと表示の分離

  

```typescript

// ========================================

// 【Container】app/_components/employees/EmployeeListContainer.tsx

// ========================================

// Jotai を使用した状態管理を担当

  

"use client";

  

import { useAtom, useAtomValue, useSetAtom } from "jotai";

import { useEffect } from "react";

import {

  employeeListAtom,

  filteredEmployeesAtom,

  searchKeywordAtom,

  selectedDepartmentAtom,

} from "@/app/_stores/employeeListAtoms";

import { EmployeeList } from "./EmployeeList";

  

interface Props {

  initialEmployees: EmployeeProfile[];

}

  

export function EmployeeListContainer({ initialEmployees }: Props) {

  // ✅ Container: 状態管理はここで

  const setEmployeeList = useSetAtom(employeeListAtom);

  const filteredEmployees = useAtomValue(filteredEmployeesAtom);

  const [keyword, setKeyword] = useAtom(searchKeywordAtom);

  const [department, setDepartment] = useAtom(selectedDepartmentAtom);

  

  // ✅ Container: 初期化ロジックはここで

  useEffect(() => {

    setEmployeeList(initialEmployees);

  }, [initialEmployees, setEmployeeList]);

  

  // ✅ Container: イベントハンドラを定義して子に渡す

  return (

    <EmployeeList

      employees={filteredEmployees}

      keyword={keyword}

      department={department}

      onKeywordChange={setKeyword}

      onDepartmentChange={setDepartment}

    />

  );

}

```

  

```typescript

// ========================================

// 【Presentational】app/_components/employees/EmployeeList.tsx

// ========================================

// Propsのみで動作する純粋な表示コンポーネント

  

"use client";

  

import { EmployeeProfile } from "@/app/_types/employee";

import { EmployeeCard } from "./EmployeeCard";

  

interface Props {

  employees: EmployeeProfile[];

  keyword: string;

  department: string;

  onKeywordChange: (value: string) => void;

  onDepartmentChange: (value: string) => void;

}

  

// ✅ Presentational: Propsだけで完全に動作

// ✅ Presentational: Jotai/状態管理の知識は不要

export function EmployeeList({

  employees,

  keyword,

  department,

  onKeywordChange,

  onDepartmentChange,

}: Props) {

  return (

    <div>

      <input

        value={keyword}

        onChange={(e) => onKeywordChange(e.target.value)}

        placeholder="検索..."

      />

  

      <select

        value={department}

        onChange={(e) => onDepartmentChange(e.target.value)}

      >

        <option value="">すべての部署</option>

        {/* ... */}

      </select>

  

      <div className="grid gap-4">

        {employees.map((emp) => (

          <EmployeeCard key={emp.basicInfo.id} employee={emp} />

        ))}

      </div>

    </div>

  );

}

```

  

```typescript

// ========================================

// 【Presentational】app/_components/employees/EmployeeCard.tsx

// ========================================

// 最小単位の表示コンポーネント

  

"use client";

  

import { EmployeeProfile } from "@/app/_types/employee";

  

interface Props {

  employee: EmployeeProfile;

}

  

// ✅ Presentational: シンプル、テスト容易、再利用可能

export function EmployeeCard({ employee }: Props) {

  return (

    <div className="p-4 border rounded-lg">

      <h3 className="text-lg font-bold">{employee.basicInfo.name}</h3>

      <p className="text-gray-600">{employee.basicInfo.department}</p>

      <p className="text-sm text-gray-500">{employee.basicInfo.position}</p>

    </div>

  );

}

```

  

---

  

### 具象5: Jotai 状態管理の実装

  

**原則**: 必要最小限の状態を原子的に管理

  

```typescript

// ========================================

// app/_stores/employeeListAtoms.ts

// ========================================

  

import { atom } from "jotai";

import { EmployeeProfile, StrengthName } from "@/app/_types/employee";

  

// ----------------------------------------

// プリミティブ Atom（基本状態）

// ----------------------------------------

  

// 社員リスト全体（Server から受け取る）

export const employeeListAtom = atom<EmployeeProfile[]>([]);

  

// 検索キーワード

export const searchKeywordAtom = atom<string>("");

  

// 選択された部署

export const selectedDepartmentAtom = atom<string>("");

  

// 選択された資質（複数選択可）

export const selectedStrengthsAtom = atom<StrengthName[]>([]);

  

// ----------------------------------------

// 派生 Atom（計算結果）

// ----------------------------------------

  

// フィルタリングされた社員リスト（読み取り専用）

export const filteredEmployeesAtom = atom((get) => {

  const employees = get(employeeListAtom);

  const keyword = get(searchKeywordAtom).toLowerCase();

  const department = get(selectedDepartmentAtom);

  const strengths = get(selectedStrengthsAtom);

  

  return employees.filter((emp) => {

    // キーワードフィルタ（2文字以上で発動）

    if (keyword.length >= 2) {

      const name = emp.basicInfo.name.toLowerCase();

      if (!name.includes(keyword)) return false;

    }

  

    // 部署フィルタ

    if (department && emp.basicInfo.department !== department) {

      return false;

    }

  

    // 資質フィルタ（Top5に含まれるか）

    if (strengths.length > 0) {

      const topStrengths = emp.strengths.slice(0, 5).map((s) => s.name);

      const hasMatch = strengths.some((s) => topStrengths.includes(s));

      if (!hasMatch) return false;

    }

  

    return true;

  });

});

  

// 部署リスト（重複なし）

export const departmentsAtom = atom((get) => {

  const employees = get(employeeListAtom);

  const departments = new Set(employees.map((e) => e.basicInfo.department));

  return [...departments].sort();

});

  

// 検索結果件数

export const resultCountAtom = atom((get) => {

  return get(filteredEmployeesAtom).length;

});

```

  

**Jotai設計のポイント**:

1. **プリミティブ Atom**: 単一の値を持つ（分割統治）

2. **派生 Atom**: 他のAtomから計算（キャッシュされる）

3. **読み取り専用 Atom**: `atom((get) => ...)` で定義

  

---

  

## ディレクトリ設計の意図

  

### ディレクトリ構造の設計思想

  

```

apps/sample1/

├── app/                      # 【Presentation Layer】

│   │

│   ├── employees/            # 機能別ルーティング

│   │   ├── page.tsx          # 一覧（Server Component）

│   │   └── [id]/

│   │       └── page.tsx      # 詳細（Server Component）

│   │

│   ├── _components/          # 【Application Layer - UI】

│   │   ├── employees/        # 機能別コンポーネント

│   │   ├── profile/

│   │   └── ui/               # 汎用コンポーネント

│   │

│   ├── _stores/              # 【Application Layer - 状態】

│   │   └── employeeListAtoms.ts

│   │

│   ├── _hooks/               # 【Application Layer - ロジック】

│   │   └── useProfileEdit.ts

│   │

│   ├── _types/               # 【横断的関心事 - 型】

│   │   └── employee.ts

│   │

│   └── _mocks/               # 【開発支援】

│       └── employeeData.ts

│

└── db/                       # 【Data Layer】

    ├── schema.ts             # テーブル定義

    ├── queries/

    │   └── employees.ts      # クエリ関数

    └── index.ts              # DB接続

```

  

### 各ディレクトリの役割と意図

  

| ディレクトリ | 役割 | 設計意図 |

|------------|------|---------|

| `app/[feature]/` | ページ（ルート） | **ユーザーの動線**に対応。URLとディレクトリが1:1 |

| `app/_components/` | UIコンポーネント | **関心事のコロケーション**。機能に近い場所に配置 |

| `app/_stores/` | 状態管理 | **機能別に分離**。肥大化を防ぐ |

| `app/_hooks/` | カスタムフック | **ロジックの再利用**。コンポーネントから抽出 |

| `app/_types/` | 型定義 | **ドメイン知識の集約**。全層から参照 |

| `app/_mocks/` | モックデータ | **開発効率**。Storybook/テストで使用 |

| `db/` | データベース | **データ層の分離**。UIから独立 |

  

### `_` プレフィックスの意味

  

```

【Next.js のルーティング規則】

  

✅ ルートになるディレクトリ

   app/employees/page.tsx  →  /employees

  

❌ ルートにならないディレクトリ（プライベート）

   app/_components/        →  ルーティング対象外

   app/_stores/            →  ルーティング対象外

   app/_hooks/             →  ルーティング対象外

  

【なぜ `_` を使うのか】

1. Next.js がルートとして認識しない

2. プライベートな内部モジュールであることが明確

3. ディレクトリをページ近くに配置できる（コロケーション）

```

  

---

  

## テンプレートとして使う際のポイント

  

### 1. 何を残し、何を削除するか

  

```

【必ず残すもの（インフラ）】

├── app/layout.tsx          # ルートレイアウト

├── app/globals.css         # グローバルスタイル

├── app/_components/ui/     # 汎用UIコンポーネント

├── db/index.ts             # DB接続

├── next.config.ts          # Next.js設定

├── tsconfig.json           # TypeScript設定

├── drizzle.config.ts       # Drizzle設定

└── package.json            # 依存関係

  

【削除すべきもの（サンプル実装）】

├── app/employees/          # サンプル機能

├── app/compatibility/      # サンプル機能

├── app/_components/employees/  # サンプルコンポーネント

├── app/_stores/employeeListAtoms.ts  # サンプル状態

├── app/_types/employee.ts  # サンプル型定義

├── db/queries/employees.ts # サンプルクエリ

└── db/schema.ts の内容     # サンプルテーブル

```

  

### 2. 新機能追加のワークフロー

  

```

Step 1: 型定義から始める

└── app/_types/yourFeature.ts

  

Step 2: データベーススキーマ

└── db/schema.ts にテーブル追加

└── pnpm db:push

  

Step 3: クエリ関数

└── db/queries/yourFeature.ts

  

Step 4: Jotai Atoms（必要なら）

└── app/_stores/yourFeatureAtoms.ts

  

Step 5: コンポーネント

└── app/_components/yourFeature/

    ├── YourFeatureContainer.tsx  # Container

    └── YourFeatureCard.tsx       # Presentational

  

Step 6: ページ

└── app/your-feature/page.tsx

```

  

### 3. 設計原則を守るためのチェックリスト

  

```

□ Server Component でデータを取得しているか？

□ "use client" は必要最小限か？

□ 型は先に定義されているか？

□ コンポーネントは50行以下か？

□ Container と Presentational は分離されているか？

□ Presentational は Props だけで動作するか？

□ 状態管理は機能別に分かれているか？

□ Data Layer は UI Layer から独立しているか？

```

  

### 4. 置き換え可能な部分

  

| 現在の実装 | 置き換え候補 | 影響範囲 |

|-----------|-------------|---------|

| SQLite | PostgreSQL, MySQL | db/ のみ |

| Drizzle | Prisma, Kysely | db/ のみ |

| Jotai | Zustand, Redux | _stores/, _components/ |

| Tailwind | styled-components, CSS Modules | スタイル全体 |

| Vitest | Jest | テスト設定のみ |

  

---

  

## まとめ

  

### 抽象レイヤー（持ち運べる知識）

  

1. **Server-First**: データはサーバーで取得、UIはクライアントで操作

2. **関心の分離**: 各層は自分の責務のみ、他の詳細は知らない

3. **型駆動設計**: 型が仕様、実装は型に従う

4. **Container/Presentational**: ロジックと表示を分離

5. **単一責任**: 1モジュール = 1責務

  

### 具象レイヤー（このリポジトリ固有）

  

1. **Next.js App Router + RSC**: Server Component でデータ取得

2. **Drizzle + SQLite**: 型安全なORM、ローカル開発に最適

3. **Jotai**: 軽量な原子的状態管理

4. **`_` プレフィックス**: プライベートディレクトリのコロケーション

5. **機能別ディレクトリ**: 関連ファイルを近くに配置

  

---

  

**関連ドキュメント**:

- [ARCHITECTURE.md](./ARCHITECTURE.md) - 技術的な詳細

- [TEMPLATE_GUIDE.md](./TEMPLATE_GUIDE.md) - テンプレートの使い方

- [README.md](README.md) - クイックスタート